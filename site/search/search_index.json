{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Aphril's Widget Library","text":"<p>Welcome to the official documentation for Aphril\u2019s Widget Library.</p> <p>Aphril\u2019s Widget Library (AWL) is a style-agnostic, material-driven UI system built around modular composition, procedural flexibility, and production-ready efficiency\u2014so teams can ship polished interfaces without building a widget library from scratch.</p> <p>Technical documentation for all products can be found using the navigation on the left.</p>"},{"location":"#fab-store","title":"Fab Store","text":"<p>Silverkeep Studios \u2013 Aphril</p>"},{"location":"#product-support","title":"Product Support","text":"<p>For bug reports, feature requests, or technical issues, please use our GitHub issue tracker</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#about","title":"About","text":"<p>Aphril\u2019s Widget Library (AWL) is a line of widgets for Unreal Engine 5.</p> <p>The goal of Aphril\u2019s Widget Library is to provide creators with a modular library of flexible, configurable, high-quality widgets needed to build user interfaces quickly and efficiently.</p> <p>AWL widgets are designed to integrate cleanly into your existing game UI design, providing high-quality, configurable procedural effects, animations, and theming. This allows your team to focus on building the game itself rather than creating a complete widget library from scratch.</p> <p>In addition to procedural effects, AWL uses a thoughtful texture stack that allows users to apply a variety of texture-based effects\u2014such as grunge, background, noise, and stencils\u2014to their widgets.</p> <p>All widgets are built using a hybrid grayscale texture and parameterized material approach, allowing materials to be easily tuned to match the desired visual style of the project.</p> <p>This approach enables maximum stylistic flexibility. You can:</p> <ul> <li>Retheme any widget by adjusting material colors</li> <li>Modify animations by manipulating material parameters in Sequencer</li> <li>Control styling for every widget using the full flexibility of Common UI styles</li> <li>Change the overall feel of widgets by swapping textures (grunge, noise, background, stencils) and adjusting their intensity</li> <li>Create entirely new widget styles by supplying custom grayscale shape textures  </li> </ul>"},{"location":"design-pillars/","title":"Product Design Pillars","text":"<p>These are the four pillars that guide our product design.</p>"},{"location":"design-pillars/#design-excellence","title":"Design Excellence","text":"<ul> <li>Every product is documented extensively</li> <li>All parameters are categorized, include descriptions and defaults, and are clamped to sane input ranges</li> <li>All code follows SOLID design principles</li> <li>Every product goes through multiple QA passes before being listed</li> </ul>"},{"location":"design-pillars/#style-agnostic-by-design","title":"Style-Agnostic by Design","text":"<p>AWL widgets are built to adapt to your game\u2019s visual language, not impose their own.</p> <ul> <li>Hybrid grayscale textures and parameterized materials form the foundation</li> <li>Retheming is handled through materials, styles, and parameters\u2014not asset replacement</li> <li>Texture stacks (grunge, noise, background, stencils) reduce custom art requirements</li> </ul>"},{"location":"design-pillars/#material-driven-flexibility","title":"Material-Driven Flexibility","text":"<p>Visual behavior is controlled through materials and parameters, not hardcoded logic or baked assets.</p> <ul> <li>All visual properties are animatable via Sequencer</li> <li>Effect intensity, textures, and colors are fully exposed and tunable</li> <li>Procedural effects live in materials, not Blueprint logic</li> </ul>"},{"location":"design-pillars/#composable-modular-architecture","title":"Composable, Modular Architecture","text":"<p>Widgets are building blocks, not sealed products.</p> <ul> <li>Designed to slot cleanly into existing UIs</li> <li>Modular structure supports reparenting, extension, and recomposition</li> <li>Common UI styles are treated as first-class citizens</li> <li>Encourages reuse, consistency, and rapid iteration  </li> </ul>"},{"location":"requirements/","title":"Requirements","text":""},{"location":"requirements/#dependencies","title":"Dependencies:","text":""},{"location":"requirements/#uimateriallab","title":"UiMaterialLab","text":""},{"location":"requirements/#commonui","title":"CommonUi","text":""},{"location":"requirements/#engine-version","title":"Engine Version:","text":""},{"location":"requirements/#unreal-engine-56","title":"Unreal Engine 5.6","text":""},{"location":"button-pack/button-pack-creating-new-buttons/","title":"Creating new buttons","text":"<p>under construction</p> <p>guide to creating new button shapes using krita and packing them correctly</p>"},{"location":"button-pack/button-pack-installation/","title":"Installation Guide","text":""},{"location":"button-pack/button-pack-installation/#basic-installation","title":"Basic Installation","text":"<ol> <li>Unzip the downloaded archive into your project\u2019s plugin directory: <code>Project/Plugins/</code></li> </ol> <p>After extraction, you should have: <code>Project/Plugins/AphrilsWidgetLibrary_Buttons</code></p> <ol> <li>Enable the plugin:</li> <li>Either add it directly to your <code>.uproject</code> file, or</li> <li> <p>Enable it through the editor: Edit \u2192 Plugins \u2192 Enable <code>AphrilsWidgetLibrary_Buttons</code></p> </li> <li> <p>Install UiMaterialLab:</p> </li> <li>Download the UiMaterialLab project from Fab</li> <li> <p>Copy the <code>Content/UiMaterialLab</code> folder into your project\u2019s <code>Content</code> directory</p> </li> <li> <p>Enable plugin content visibility:</p> </li> <li>Open the Content Drawer</li> <li>Click the gear icon (top-right)</li> <li>Enable Show Plugin Content</li> </ol>"},{"location":"button-pack/button-pack-installation/#optional-verification-steps","title":"Optional Verification Steps","text":"<ol> <li> <p>In the Content Drawer, right-click and select: User Interface \u2192 Widget Blueprint</p> </li> <li> <p>Open the newly created Widget Blueprint</p> </li> <li> <p>In the Palette, locate Aphril\u2019s Widget Library (Defaults to the upper center-left area of the palette)</p> </li> <li> <p>You should see five buttons available</p> </li> </ol>"},{"location":"button-pack/button-pack-installation/#recommended-project-setup","title":"Recommended Project Setup","text":"<ol> <li>In <code>Project/Content</code>, create the following folders:</li> <li><code>WidgetLibrary</code></li> <li> <p><code>WidgetLibrary/Buttons</code></p> </li> <li> <p>Use these folders for:</p> </li> <li>User-owned Material Instances</li> <li>Widget Blueprints</li> <li>Common UI styles</li> </ol> <p>This keeps project-specific customization cleanly separated from plugin content.</p>"},{"location":"button-pack/button-pack-installation/#your-first-awl-button","title":"Your First AWL Button","text":"<ol> <li>Duplicate a Material Instance from the plugin</li> <li> <p>Move it into <code>WidgetLibrary/Buttons</code></p> </li> <li> <p>Adjust the material instance to your preferred style</p> </li> <li> <p>Duplicate a HexButton from the plugin</p> </li> <li> <p>Move it into <code>WidgetLibrary/Buttons</code></p> </li> <li> <p>Update your duplicated button\u2019s Variable Defaults:</p> </li> <li>Open the widget in the Widget Blueprint Editor</li> <li>Click Event Graph (top-right)</li> <li>Locate the Variables panel on the left</li> <li>Expand the Appearance category</li> <li>Select the Button Image variable</li> </ol> <p>If the Details panel does not appear:   - Top menu \u2192 Window \u2192 Details</p> <p>In the Details panel for <code>Button Image</code>:   - Set Default Value \u2192 Button Image   - Assign your configured Material Instance from <code>WidgetLibrary/Buttons</code></p> <ol> <li>Your newly themed button should now appear in the Aphril\u2019s Widget Library category in the Widget Palette</li> </ol>"},{"location":"button-pack/button-pack-installation/#adding-your-button-to-the-common-category-optional","title":"Adding Your Button to the Common Category (Optional)","text":"<p>To place your button in the Common category (Common UI default for user-created widgets):</p> <ol> <li>Open your button widget</li> <li>Top menu \u2192 File \u2192 Reparent Blueprint</li> <li>Select <code>CommonButtonBase</code></li> </ol>"},{"location":"button-pack/button-pack-installation/#creating-your-own-palette-category-advanced","title":"Creating Your Own Palette Category (Advanced)","text":"<ol> <li>Use the <code>UAwlMaterialButton</code> class as a baseline for a new C++ class</li> <li>Use your own class name to avoid One Definition Rule (ODR) violations</li> <li>Override <code>GetPaletteCategory()</code> to return your desired category name</li> <li>Reparent the widgets you want in the new category to this new class.</li> </ol>"},{"location":"button-pack/button-pack-installation/#additional-notes","title":"Additional Notes","text":"<p>This duplication-based workflow provides a strong default setup that includes: - Built-in animations - All AWL default behavior - Instance-editable properties</p> <p>This allows you to: - Edit styling, button images, text styling, and text per widget - Adjust defaults by editing variable default values in the Event Graph - Customize buttons directly inside UMG Widget Blueprints (e.g., menus)</p>"},{"location":"button-pack/button-pack-styling/","title":"Styling","text":"<p>under construction</p>"},{"location":"button-pack/button-pack-widget-blueprints/","title":"Widget Blueprints","text":"<p>under construction</p>"},{"location":"button-pack/changelog/","title":"Changelog","text":""},{"location":"button-pack/changelog/#100","title":"1.0.0","text":"<p>Initial Release</p>"}]}